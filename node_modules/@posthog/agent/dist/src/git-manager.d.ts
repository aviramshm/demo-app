import { Logger } from './utils/logger.js';
export interface GitConfig {
    repositoryPath: string;
    authorName?: string;
    authorEmail?: string;
    logger?: Logger;
}
export interface BranchInfo {
    name: string;
    exists: boolean;
    isCurrentBranch: boolean;
}
export declare class GitManager {
    private repositoryPath;
    private authorName?;
    private authorEmail?;
    private logger;
    constructor(config: GitConfig);
    private escapeShellArg;
    private runGitCommand;
    private runCommand;
    isGitRepository(): Promise<boolean>;
    getCurrentBranch(): Promise<string>;
    getDefaultBranch(): Promise<string>;
    branchExists(branchName: string): Promise<boolean>;
    createBranch(branchName: string, baseBranch?: string): Promise<void>;
    switchToBranch(branchName: string): Promise<void>;
    resetToDefaultBranchIfNeeded(): Promise<boolean>;
    createOrSwitchToBranch(branchName: string, baseBranch?: string): Promise<void>;
    addFiles(paths: string[]): Promise<void>;
    addAllPostHogFiles(): Promise<void>;
    commitChanges(message: string, options?: {
        authorName?: string;
        authorEmail?: string;
    }): Promise<string>;
    hasChanges(): Promise<boolean>;
    hasStagedChanges(): Promise<boolean>;
    private ensureCleanWorkingDirectory;
    private generateUniqueBranchName;
    private ensureOnDefaultBranch;
    private buildCommitCommand;
    getRemoteUrl(): Promise<string | null>;
    pushBranch(branchName: string, force?: boolean): Promise<void>;
    /**
     * Tracks whether commits were made during an operation by comparing HEAD SHA
     * before and after. Returns an object with methods to finalize the operation.
     *
     * Usage:
     * const tracker = await gitManager.trackCommitsDuring();
     * // ... do work that might create commits ...
     * const result = await tracker.finalize({ commitMessage: 'fallback message', push: true });
     */
    trackCommitsDuring(): Promise<{
        finalize: (options: {
            commitMessage: string;
            push?: boolean;
        }) => Promise<{
            commitCreated: boolean;
            pushedBranch: boolean;
        }>;
    }>;
    createTaskBranch(taskSlug: string): Promise<string>;
    createTaskPlanningBranch(taskId: string, baseBranch?: string): Promise<string>;
    createTaskImplementationBranch(taskId: string, planningBranchName?: string): Promise<string>;
    commitPlan(taskId: string, taskTitle: string): Promise<string>;
    commitImplementation(taskId: string, taskTitle: string, planSummary?: string): Promise<string>;
    deleteBranch(branchName: string, force?: boolean): Promise<void>;
    deleteRemoteBranch(branchName: string): Promise<void>;
    getBranchInfo(branchName: string): Promise<BranchInfo>;
    getCommitSha(ref?: string): Promise<string>;
    getCommitMessage(ref?: string): Promise<string>;
    createPullRequest(branchName: string, title: string, body: string, baseBranch?: string): Promise<string>;
    getTaskBranch(taskSlug: string): Promise<string | null>;
    commitAndPush(message: string, options?: {
        allowEmpty?: boolean;
    }): Promise<void>;
}
//# sourceMappingURL=git-manager.d.ts.map