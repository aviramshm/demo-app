import { promises } from 'fs';
import { join, dirname } from 'path';
import { Logger } from './utils/logger.js';

class PostHogFileManager {
    repositoryPath;
    logger;
    constructor(repositoryPath, logger) {
        this.repositoryPath = repositoryPath;
        this.logger = logger || new Logger({ debug: false, prefix: '[FileManager]' });
    }
    getTaskDirectory(taskId) {
        return join(this.repositoryPath, '.posthog', taskId);
    }
    getTaskFilePath(taskId, fileName) {
        return join(this.getTaskDirectory(taskId), fileName);
    }
    async ensureTaskDirectory(taskId) {
        const taskDir = this.getTaskDirectory(taskId);
        try {
            await promises.access(taskDir);
        }
        catch {
            await promises.mkdir(taskDir, { recursive: true });
        }
    }
    async writeTaskFile(taskId, file) {
        await this.ensureTaskDirectory(taskId);
        const filePath = this.getTaskFilePath(taskId, file.name);
        this.logger.debug('Writing task file', {
            filePath,
            contentLength: file.content.length,
            contentType: typeof file.content
        });
        await promises.writeFile(filePath, file.content, 'utf8');
        this.logger.debug('File written successfully', { filePath });
    }
    async readTaskFile(taskId, fileName) {
        try {
            const filePath = this.getTaskFilePath(taskId, fileName);
            return await promises.readFile(filePath, 'utf8');
        }
        catch (error) {
            if (error.code === 'ENOENT') {
                return null;
            }
            throw error;
        }
    }
    async listTaskFiles(taskId) {
        try {
            const taskDir = this.getTaskDirectory(taskId);
            const files = await promises.readdir(taskDir);
            return files.filter(file => !file.startsWith('.'));
        }
        catch (error) {
            if (error.code === 'ENOENT') {
                return [];
            }
            throw error;
        }
    }
    async deleteTaskFile(taskId, fileName) {
        try {
            const filePath = this.getTaskFilePath(taskId, fileName);
            await promises.unlink(filePath);
        }
        catch (error) {
            if (error.code !== 'ENOENT') {
                throw error;
            }
        }
    }
    async taskDirectoryExists(taskId) {
        try {
            const taskDir = this.getTaskDirectory(taskId);
            await promises.access(taskDir);
            return true;
        }
        catch {
            return false;
        }
    }
    async cleanupTaskDirectory(taskId) {
        try {
            const taskDir = this.getTaskDirectory(taskId);
            await promises.rm(taskDir, { recursive: true, force: true });
        }
        catch (error) {
            if (error.code !== 'ENOENT') {
                throw error;
            }
        }
    }
    // Convenience methods for common file types
    async writePlan(taskId, plan) {
        this.logger.debug('Writing plan', {
            taskId,
            planLength: plan.length,
            contentPreview: plan.substring(0, 200)
        });
        await this.writeTaskFile(taskId, {
            name: 'plan.md',
            content: plan,
            type: 'plan'
        });
        this.logger.info('Plan file written', { taskId });
    }
    async readPlan(taskId) {
        return await this.readTaskFile(taskId, 'plan.md');
    }
    async writeContext(taskId, context) {
        await this.writeTaskFile(taskId, {
            name: 'context.md',
            content: context,
            type: 'context'
        });
    }
    async readContext(taskId) {
        return await this.readTaskFile(taskId, 'context.md');
    }
    async writeRequirements(taskId, requirements) {
        await this.writeTaskFile(taskId, {
            name: 'requirements.md',
            content: requirements,
            type: 'reference'
        });
    }
    async readRequirements(taskId) {
        return await this.readTaskFile(taskId, 'requirements.md');
    }
    async writeResearch(taskId, content) {
        this.logger.debug('Writing research', {
            taskId,
            contentLength: content.length,
            contentPreview: content.substring(0, 200)
        });
        await this.writeTaskFile(taskId, {
            name: 'research.md',
            content: content,
            type: 'artifact'
        });
        this.logger.info('Research file written', { taskId });
    }
    async readResearch(taskId) {
        return await this.readTaskFile(taskId, 'research.md');
    }
    async writeQuestions(taskId, data) {
        this.logger.debug('Writing questions', {
            taskId,
            questionCount: data.questions.length,
            answered: data.answered,
        });
        await this.writeTaskFile(taskId, {
            name: 'questions.json',
            content: JSON.stringify(data, null, 2),
            type: 'artifact'
        });
        this.logger.info('Questions file written', { taskId });
    }
    async readQuestions(taskId) {
        try {
            const content = await this.readTaskFile(taskId, 'questions.json');
            return content ? JSON.parse(content) : null;
        }
        catch (error) {
            this.logger.debug('Failed to parse questions.json', { error });
            return null;
        }
    }
    async getTaskFiles(taskId) {
        const fileNames = await this.listTaskFiles(taskId);
        const files = [];
        for (const fileName of fileNames) {
            const content = await this.readTaskFile(taskId, fileName);
            if (content !== null) {
                // Determine type based on file name
                let type = 'reference';
                if (fileName === 'plan.md')
                    type = 'plan';
                else if (fileName === 'context.md')
                    type = 'context';
                else if (fileName === 'requirements.md')
                    type = 'reference';
                else if (fileName.startsWith('output_'))
                    type = 'output';
                files.push({
                    name: fileName,
                    content,
                    type,
                    created_at: new Date().toISOString() // Could be enhanced with file stats
                });
            }
        }
        return files;
    }
    async ensureGitignore() {
        const gitignorePath = join(this.repositoryPath, '.posthog', '.gitignore');
        const gitignoreContent = `# PostHog task artifacts - customize as needed
# Exclude temporary files
*/temp/
*/cache/
*/.env
*/.secrets

# Include plans and documentation by default
!*/plan.md
!*/context.md
!*/requirements.md
!*/README.md
`;
        try {
            await promises.access(gitignorePath);
        }
        catch {
            await promises.mkdir(dirname(gitignorePath), { recursive: true });
            await promises.writeFile(gitignorePath, gitignoreContent, 'utf8');
        }
    }
}

export { PostHogFileManager };
//# sourceMappingURL=file-manager.js.map
