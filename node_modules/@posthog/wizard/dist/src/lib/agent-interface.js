"use strict";
/**
 * Shared agent interface for PostHog wizards
 * Provides common agent initialization and event handling
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.initializeAgent = initializeAgent;
exports.runAgent = runAgent;
// @ts-ignore - posthog-agent is ESM, wizard is CommonJS. Works at runtime via local link.
const agent_1 = require("@posthog/agent");
const clack_1 = __importDefault(require("../utils/clack"));
const debug_1 = require("../utils/debug");
const analytics_1 = require("../utils/analytics");
const constants_1 = require("./constants");
// TODO: Remove these if/when posthog/agent exports an enum for events
const EventType = {
    RAW_SDK_EVENT: 'raw_sdk_event',
    TOKEN: 'token',
    TOOL_CALL: 'tool_call',
    TOOL_RESULT: 'tool_result',
    ERROR: 'error',
    DONE: 'done',
};
/**
 * Initialize a PostHog Agent instance with the provided configuration
 */
function initializeAgent(config, options, spinner) {
    clack_1.default.log.step('Initializing PostHog agent...');
    try {
        const agentConfig = {
            workingDirectory: config.workingDirectory,
            posthogMcpUrl: config.posthogMcpUrl,
            posthogApiKey: config.posthogApiKey,
            onEvent: (event) => {
                handleAgentEvent(event, options, spinner);
            },
            debug: config.debug ?? false,
        };
        if (options.debug) {
            (0, debug_1.debug)('Agent config:', {
                workingDirectory: agentConfig.workingDirectory,
                posthogMcpUrl: agentConfig.posthogMcpUrl,
                posthogApiKeyPresent: !!agentConfig.posthogApiKey,
            });
        }
        const agent = new agent_1.Agent(agentConfig);
        clack_1.default.log.success("Agent initialized. Let's get cooking!");
        return agent;
    }
    catch (error) {
        clack_1.default.log.error(`Failed to initialize agent: ${error.message}`);
        (0, debug_1.debug)('Agent initialization error:', error);
        throw error;
    }
}
/**
 * Handle agent events and provide user feedback
 * This function processes events from the agent SDK and provides appropriate
 * user feedback through the CLI spinner and logging
 */
function handleAgentEvent(event, options, spinner) {
    if (options.debug) {
        (0, debug_1.debug)(`Event type: ${event.type}`, JSON.stringify(event, null, 2));
    }
    // Only show [STATUS] events to the user - everything else goes to debug log
    switch (event.type) {
        case EventType.RAW_SDK_EVENT:
            if (event.sdkMessage?.type === 'assistant') {
                const message = event.sdkMessage.message;
                if (message?.content && Array.isArray(message.content)) {
                    const textContent = message.content
                        .filter((block) => block.type === 'text')
                        .map((block) => block.text)
                        .join('\n');
                    // Check if the text contains a [STATUS] marker
                    const statusMatch = textContent.match(/^.*\[STATUS\]\s*(.+?)$/m);
                    if (statusMatch) {
                        // Stop spinner, log the status step, restart spinner
                        // This creates the progress list as the agent proceeds
                        spinner.stop(statusMatch[1].trim());
                        spinner.start('Integrating PostHog...');
                    }
                }
            }
            break;
        case EventType.TOKEN:
            if (options.debug) {
                (0, debug_1.debug)(event.content);
            }
            break;
        case EventType.TOOL_CALL:
            if (options.debug) {
                (0, debug_1.debug)(`Tool: ${event.toolName}`);
                (0, debug_1.debug)('  Args:', JSON.stringify(event.args, null, 2));
            }
            break;
        case EventType.TOOL_RESULT:
            if (options.debug) {
                (0, debug_1.debug)(`âœ… ${event.toolName} completed`);
                const resultStr = typeof event.result === 'string'
                    ? event.result
                    : JSON.stringify(event.result, null, 2);
                const truncated = resultStr.length > 500
                    ? `${resultStr.substring(0, 500)}...`
                    : resultStr;
                (0, debug_1.debug)('  Result:', truncated);
            }
            break;
        case EventType.ERROR:
            // Always show errors to user
            clack_1.default.log.error(`Error: ${event.message}`);
            if (options.debug && event.error) {
                (0, debug_1.debug)('Error details:', event.error);
            }
            if (event.error instanceof Error) {
                analytics_1.analytics.captureException(event.error, {
                    event_type: event.type,
                    message: event.message,
                });
            }
            break;
        case EventType.DONE:
            if (event.durationMs) {
                if (options.debug) {
                    (0, debug_1.debug)(`Completed in ${Math.round(event.durationMs / 1000)}s`);
                }
                analytics_1.analytics.capture(constants_1.WIZARD_INTERACTION_EVENT_NAME, {
                    action: 'agent integration completed',
                    duration_ms: event.durationMs,
                    duration_seconds: Math.round(event.durationMs / 1000),
                });
            }
            break;
    }
}
/**
 * Execute an agent with the provided prompt and options
 * Handles the full lifecycle: spinner, execution, error handling
 */
async function runAgent(agent, prompt, options, spinner, config) {
    const { estimatedDurationMinutes = 8, spinnerMessage = 'Customizing your PostHog setup...', successMessage = 'PostHog integration complete', errorMessage = 'Integration failed', } = config ?? {};
    clack_1.default.log.step(`This whole process should take about ${estimatedDurationMinutes} minutes including error checking and fixes.\n\nGrab some coffee!`);
    spinner.start(spinnerMessage);
    try {
        await agent.run(prompt, {
            repositoryPath: options.installDir,
            permissionMode: agent_1.PermissionMode.ACCEPT_EDITS,
        });
        spinner.stop(successMessage);
    }
    catch (error) {
        spinner.stop(errorMessage);
        clack_1.default.log.error(`Error: ${error.message}`);
        (0, debug_1.debug)('Full error:', error);
        throw error;
    }
}
//# sourceMappingURL=agent-interface.js.map