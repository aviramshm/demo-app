"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runWizard = runWizard;
const clack_utils_1 = require("./utils/clack-utils");
const nextjs_wizard_1 = require("./nextjs/nextjs-wizard");
const nextjs_wizard_agent_1 = require("./nextjs/nextjs-wizard-agent");
const constants_1 = require("./lib/constants");
const environment_1 = require("./utils/environment");
const clack_1 = __importDefault(require("./utils/clack"));
const path_1 = __importDefault(require("path"));
const config_1 = require("./lib/config");
const react_wizard_1 = require("./react/react-wizard");
const analytics_1 = require("./utils/analytics");
const svelte_wizard_1 = require("./svelte/svelte-wizard");
const react_native_wizard_1 = require("./react-native/react-native-wizard");
const astro_wizard_1 = require("./astro/astro-wizard");
const events_1 = require("events");
const chalk_1 = __importDefault(require("chalk"));
const errors_1 = require("./utils/errors");
const package_json_1 = require("./utils/package-json");
const semver = __importStar(require("semver"));
events_1.EventEmitter.defaultMaxListeners = 50;
async function runWizard(argv) {
    const finalArgs = {
        ...argv,
        ...(0, environment_1.readEnvironment)(),
    };
    let resolvedInstallDir;
    if (finalArgs.installDir) {
        if (path_1.default.isAbsolute(finalArgs.installDir)) {
            resolvedInstallDir = finalArgs.installDir;
        }
        else {
            resolvedInstallDir = path_1.default.join(process.cwd(), finalArgs.installDir);
        }
    }
    else {
        resolvedInstallDir = process.cwd();
    }
    const wizardOptions = {
        debug: finalArgs.debug ?? false,
        forceInstall: finalArgs.forceInstall ?? false,
        installDir: resolvedInstallDir,
        cloudRegion: finalArgs.region ?? undefined,
        default: finalArgs.default ?? false,
        signup: finalArgs.signup ?? false,
    };
    clack_1.default.intro(`Welcome to the PostHog setup wizard âœ¨`);
    const integration = finalArgs.integration ?? (await getIntegrationForSetup(wizardOptions));
    analytics_1.analytics.setTag('integration', integration);
    try {
        switch (integration) {
            case constants_1.Integration.nextjs:
                await chooseNextjsWizard(wizardOptions);
                break;
            case constants_1.Integration.react:
                await (0, react_wizard_1.runReactWizard)(wizardOptions);
                break;
            case constants_1.Integration.svelte:
                await (0, svelte_wizard_1.runSvelteWizard)(wizardOptions);
                break;
            case constants_1.Integration.reactNative:
                await (0, react_native_wizard_1.runReactNativeWizard)(wizardOptions);
                break;
            case constants_1.Integration.astro:
                await (0, astro_wizard_1.runAstroWizard)(wizardOptions);
                break;
            default:
                clack_1.default.log.error('No setup wizard selected!');
        }
    }
    catch (error) {
        analytics_1.analytics.captureException(error, {
            integration,
            arguments: JSON.stringify(finalArgs),
        });
        await analytics_1.analytics.shutdown('error');
        if (error instanceof errors_1.RateLimitError) {
            clack_1.default.log.error('Wizard usage limit reached. Please try again later.');
        }
        else {
            clack_1.default.log.error(`Something went wrong. You can read the documentation at ${chalk_1.default.cyan(`${config_1.INTEGRATION_CONFIG[integration].docsUrl}`)} to set up PostHog manually.`);
        }
        process.exit(1);
    }
}
async function detectIntegration(options) {
    const integrationConfigs = Object.entries(config_1.INTEGRATION_CONFIG).sort(([a], [b]) => config_1.INTEGRATION_ORDER.indexOf(a) -
        config_1.INTEGRATION_ORDER.indexOf(b));
    for (const [integration, config] of integrationConfigs) {
        const detected = await config.detect(options);
        if (detected) {
            return integration;
        }
    }
}
async function getIntegrationForSetup(options) {
    const detectedIntegration = await detectIntegration(options);
    if (detectedIntegration) {
        clack_1.default.log.success(`Detected integration: ${(0, constants_1.getIntegrationDescription)(detectedIntegration)}`);
        return detectedIntegration;
    }
    const integration = await (0, clack_utils_1.abortIfCancelled)(clack_1.default.select({
        message: 'What do you want to set up?',
        options: [
            { value: constants_1.Integration.nextjs, label: 'Next.js' },
            { value: constants_1.Integration.astro, label: 'Astro' },
            { value: constants_1.Integration.react, label: 'React' },
            { value: constants_1.Integration.svelte, label: 'Svelte' },
            { value: constants_1.Integration.reactNative, label: 'React Native' },
        ],
    }));
    return integration;
}
async function chooseNextjsWizard(options) {
    try {
        const packageJson = await (0, clack_utils_1.getPackageDotJson)(options);
        const nextVersion = (0, package_json_1.getPackageVersion)('next', packageJson);
        // If Next.js < 15, use legacy wizard
        if (nextVersion) {
            const coercedVersion = semver.coerce(nextVersion);
            if (coercedVersion && semver.lt(coercedVersion, '15.3.0')) {
                await (0, nextjs_wizard_1.runNextjsWizard)(options);
                return;
            }
        }
        // Next.js >= 15 - check feature flag to determine which wizard to use
        const flagValue = await analytics_1.analytics.getFeatureFlag(constants_1.FeatureFlagDefinition.NextV2);
        if (flagValue === constants_1.WizardVariant.Agent) {
            await (0, nextjs_wizard_agent_1.runNextjsWizardAgent)(options);
        }
        else {
            await (0, nextjs_wizard_1.runNextjsWizard)(options);
        }
    }
    catch (error) {
        await (0, nextjs_wizard_1.runNextjsWizard)(options);
    }
}
//# sourceMappingURL=run.js.map