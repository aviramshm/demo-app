"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeMCPServer = exports.addMCPServer = exports.getInstalledClients = exports.removeMCPServerFromClientsStep = exports.addMCPServerToClientsStep = exports.getSupportedClients = void 0;
const telemetry_1 = require("../../telemetry");
const analytics_1 = require("../../utils/analytics");
const clack_1 = __importDefault(require("../../utils/clack"));
const chalk_1 = __importDefault(require("chalk"));
const clack_utils_1 = require("../../utils/clack-utils");
const cursor_1 = require("./clients/cursor");
const claude_1 = require("./clients/claude");
const mcp_1 = require("../../mcp");
const claude_code_1 = require("./clients/claude-code");
const visual_studio_code_1 = require("./clients/visual-studio-code");
const zed_1 = require("./clients/zed");
const codex_1 = require("./clients/codex");
const defaults_1 = require("./defaults");
const debug_1 = require("../../utils/debug");
const getSupportedClients = async () => {
    const allClients = [
        new cursor_1.CursorMCPClient(),
        new claude_1.ClaudeMCPClient(),
        new claude_code_1.ClaudeCodeMCPClient(),
        new visual_studio_code_1.VisualStudioCodeClient(),
        new zed_1.ZedClient(),
        new codex_1.CodexMCPClient(),
    ];
    const supportedClients = [];
    (0, debug_1.debug)('Checking for supported MCP clients...');
    for (const client of allClients) {
        const isSupported = await client.isClientSupported();
        (0, debug_1.debug)(`${client.name}: ${isSupported ? '✓ supported' : '✗ not supported'}`);
        if (isSupported) {
            supportedClients.push(client);
        }
    }
    (0, debug_1.debug)(`Found ${supportedClients.length} supported client(s): ${supportedClients
        .map((c) => c.name)
        .join(', ')}`);
    return supportedClients;
};
exports.getSupportedClients = getSupportedClients;
const addMCPServerToClientsStep = async ({ integration, cloudRegion, askPermission = true, local = false, }) => {
    const region = cloudRegion ?? (await (0, clack_utils_1.askForCloudRegion)());
    const hasPermission = askPermission
        ? await (0, clack_utils_1.abortIfCancelled)(clack_1.default.select({
            message: local
                ? 'Would you like to install the local development MCP server?'
                : 'Would you like to install the MCP server to use PostHog in your editor?',
            options: [
                { value: true, label: 'Yes' },
                { value: false, label: 'No' },
            ],
        }), integration)
        : true;
    if (!hasPermission) {
        return [];
    }
    const { groupMultiselect } = await import('@clack/prompts');
    const selectedFeatures = await (0, clack_utils_1.abortIfCancelled)(groupMultiselect({
        message: `Select which PostHog features to enable as tools: ${chalk_1.default.dim('(Toggle: Space, Confirm: Enter, Toggle All: A, Cancel: CTRL + C)')}`,
        options: defaults_1.AVAILABLE_FEATURES,
        initialValues: [...defaults_1.ALL_FEATURE_VALUES],
        required: false,
    }), integration);
    const supportedClients = await (0, exports.getSupportedClients)();
    const { multiselect } = await import('@clack/prompts');
    const selectedClientNames = await (0, clack_utils_1.abortIfCancelled)(multiselect({
        message: `Select which MCP clients to install the MCP server to: ${chalk_1.default.dim('(Toggle: Space, Confirm: Enter, Toggle All: A, Cancel: CTRL + C)')}`,
        options: supportedClients.map((client) => ({
            value: client.name,
            label: client.name,
        })),
        initialValues: supportedClients.map((client) => client.name),
        required: true,
    }), integration);
    const clients = supportedClients.filter((client) => selectedClientNames.includes(client.name));
    // Only check for existing installations in the clients the user selected
    const installedClients = [];
    for (const client of clients) {
        if (await client.isServerInstalled(local)) {
            installedClients.push(client);
        }
    }
    if (installedClients.length > 0) {
        clack_1.default.log.warn(`The MCP server is already configured for:
  ${installedClients.map((c) => `- ${c.name}`).join('\n  ')}`);
        const reinstall = await (0, clack_utils_1.abortIfCancelled)(clack_1.default.select({
            message: 'Would you like to reinstall it?',
            options: [
                {
                    value: true,
                    label: 'Yes',
                    hint: 'Reinstall the MCP server',
                },
                {
                    value: false,
                    label: 'No',
                    hint: 'Keep the existing installation',
                },
            ],
        }), integration);
        if (!reinstall) {
            analytics_1.analytics.capture('wizard interaction', {
                action: 'declined to reinstall mcp servers',
                clients: installedClients.map((c) => c.name),
                integration,
            });
            return [];
        }
        await (0, exports.removeMCPServer)(installedClients, local);
        clack_1.default.log.info('Removed existing installation.');
    }
    const personalApiKey = await (0, mcp_1.getPersonalApiKey)({ cloudRegion: region });
    await (0, telemetry_1.traceStep)('adding mcp servers', async () => {
        await (0, exports.addMCPServer)(clients, personalApiKey, selectedFeatures, local);
    });
    clack_1.default.log.success(`Added the MCP server to:
  ${clients.map((c) => `- ${c.name}`).join('\n  ')} `);
    analytics_1.analytics.capture('wizard interaction', {
        action: 'added mcp servers',
        clients: clients.map((c) => c.name),
        integration,
    });
    return clients.map((c) => c.name);
};
exports.addMCPServerToClientsStep = addMCPServerToClientsStep;
const removeMCPServerFromClientsStep = async ({ integration, local = false, }) => {
    const installedClients = await (0, exports.getInstalledClients)(local);
    if (installedClients.length === 0) {
        analytics_1.analytics.capture('wizard interaction', {
            action: 'no mcp servers to remove',
            integration,
        });
        return [];
    }
    const { multiselect } = await import('@clack/prompts');
    const selectedClientNames = await (0, clack_utils_1.abortIfCancelled)(multiselect({
        message: `Select which clients to remove the MCP server from: ${chalk_1.default.dim('(Toggle: Space, Confirm: Enter, Toggle All: A, Cancel: CTRL + C)')}`,
        options: installedClients.map((client) => ({
            value: client.name,
            label: client.name,
        })),
        initialValues: installedClients.map((client) => client.name),
    }), integration);
    const clientsToRemove = installedClients.filter((client) => selectedClientNames.includes(client.name));
    if (clientsToRemove.length === 0) {
        analytics_1.analytics.capture('wizard interaction', {
            action: 'no mcp servers selected for removal',
            integration,
        });
        return [];
    }
    const results = await (0, telemetry_1.traceStep)('removing mcp servers', async () => {
        await (0, exports.removeMCPServer)(clientsToRemove, local);
        return clientsToRemove.map((c) => c.name);
    });
    analytics_1.analytics.capture('wizard interaction', {
        action: 'removed mcp servers',
        clients: results,
        integration,
    });
    return results;
};
exports.removeMCPServerFromClientsStep = removeMCPServerFromClientsStep;
const getInstalledClients = async (local) => {
    const clients = await (0, exports.getSupportedClients)();
    const installedClients = [];
    for (const client of clients) {
        if (await client.isServerInstalled(local)) {
            installedClients.push(client);
        }
    }
    return installedClients;
};
exports.getInstalledClients = getInstalledClients;
const addMCPServer = async (clients, personalApiKey, selectedFeatures, local) => {
    for (const client of clients) {
        await client.addServer(personalApiKey, selectedFeatures, local);
    }
};
exports.addMCPServer = addMCPServer;
const removeMCPServer = async (clients, local) => {
    for (const client of clients) {
        await client.removeServer(local);
    }
};
exports.removeMCPServer = removeMCPServer;
//# sourceMappingURL=index.js.map