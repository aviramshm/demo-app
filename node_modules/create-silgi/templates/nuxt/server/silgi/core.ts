// DO NOT EDIT THIS FILE
// This file is generated by Silgi
/* eslint-disable */
/* prettier-ignore */
/* tslint:disable */
import { mergeDeep } from "silgi/runtime";
import { createSilgi } from "silgi";
import { services, shareds, schemas, middlewares, resolvers } from "./scan";
import { cliConfigs } from "./configs";
import { meta } from "./meta";
import _gAT7ncSdeP5G0leE3AKA7UClM6p3jcAhQambBD3B0 from "@silgi/openapi/runtime/plugin";
import _hMxXsgdzUv5EbR1x0gUzxLacyjE8RBwZqXVJuQmwvo from "silgi/runtime/internal/nitro";
import type { SilgiRuntimeOptions, BuildSilgi } from "silgi/types";


export async function buildSilgi(option?: BuildSilgi) {

// buildSilgiBefore

const silgi = await createSilgi({
 framework: option?.framework,
 shared: shareds,
 services: services,
 middlewares: middlewares,
 schemas: schemas,
 resolvers: resolvers,
 plugins: [_gAT7ncSdeP5G0leE3AKA7UClM6p3jcAhQambBD3B0, _hMxXsgdzUv5EbR1x0gUzxLacyjE8RBwZqXVJuQmwvo],

 captureError: (silgi, error, context = {}) => {
          const promise = silgi.hooks
            .callHookParallel('error', silgi, error, context)
            .catch((error_) => {
              console.error('Error while capturing another error', error_)
            })
    
          if (context.event && isEvent(context.event)) {
            const errors = context.event.context.nitro?.errors
            if (errors) {
              errors.push({ error, context })
            }
            if (context.event.waitUntil) {
              context.event.waitUntil(promise)
            }
          }
        },

 options: mergeDeep(cliConfigs, {
   runtimeConfig: {} as SilgiRuntimeOptions,
   meta: meta,
   present: 'nuxt',
   ...option?.modules,
   ...option?.options,
   }) as any,
 })

// buildSilgiAfter

  return silgi
}
