import { createMiddleware, createSchema, createService } from 'silgi'
import { z } from 'zod'

// Base types
const authorType = z.object({
  id: z.string(),
  name: z.string(),
})

const bookType = z.object({
  id: z.string(),
  name: z.string(),
  description: z.string().optional(),
  author: authorType.optional(),
})

// MIDDLEWARES
export const globalMiddleware = createMiddleware({
  key: 'globaltest1',
  path: 'global',
  setup: {
    handler: async (event, silgi) => {
      console.log('Global middleware executed')
    },
  },
})

export const routeMiddleware1 = createMiddleware({
  path: '/api/library/books/**',
  methods: ['GET', 'POST'],
  key: 'routeMiddleware1',
  setup: {
    handler: async (event, silgi) => {
      console.log('Route middleware executed for GET and POST books')
    },
  },
})

// SERVICES
export const getBookByIdService = createService({
  path: '/api/library/book', // id olmadan, tekil path
  method: 'GET',
  pathParams: z.object({
    id: z.string(),
  }),
  queryParams: z.object({
    includeAuthor: z.boolean().optional(),
    format: z.enum(['full', 'summary']).optional(),
  }),
  output: bookType,
  handler: async (input, shared, event) => {
    const bookId = input.path.id
    const includeAuthor = input.query?.includeAuthor ?? true
    const format = input.query?.format ?? 'full'

    if (!bookId) {
      throw new Error("Book not found")
    }

    // Simulate DB fetch
    const book = {
      id: bookId,
      name: 'Sample Book',
      description: format === 'full' ? 'Sample Description' : undefined,
      author: includeAuthor ? {
        id: 'auth-1',
        name: 'John Doe',
      } : undefined,
    }
    return book
  },
})

export const getBooksService = createService({
  path: '/api/library/books',
  method: 'GET',
  queryParams: z.object({
    limit: z.number().int().positive().optional(),
    offset: z.number().int().nonnegative().optional(),
    authorId: z.string().optional(),
    sortBy: z.enum(['name', 'date']).optional(),
  }),
  output: z.array(bookType),
  handler: async (input, shared, event) => {
    const limit = input.query?.limit ?? 10
    const offset = input.query?.offset ?? 0
    const authorId = input.query?.authorId
    const sortBy = input.query?.sortBy ?? 'name'

    const books = [
      {
        id: '1',
        name: 'Book 1',
        description: 'Description 1',
        author: {
          id: 'auth-1',
          name: 'John Doe',
        }
      },
      {
        id: '2',
        name: 'Book 2',
        description: 'Description 2',
        author: {
          id: 'auth-2',
          name: 'Jane Smith',
        }
      },
    ]

    const filteredBooks = authorId
      ? books.filter(book => book.author?.id === authorId)
      : books

    const sortedBooks = [...filteredBooks].sort((a, b) =>
      sortBy === 'name' ? a.name.localeCompare(b.name) : 0
    )

    return sortedBooks.slice(offset, offset + limit)
  },
})

export const createBookService = createService({
  path: '/api/library/books/create',
  method: 'POST',
  input: z.object({
    name: z.string(),
    description: z.string().optional(),
    authorId: z.string(),
  }),
  output: bookType,
  handler: async (input, shared, event) => {
    const { name, description, authorId } = input.args
    if (!name || !authorId) {
      throw new Error("Invalid book data")
    }
    const author = { id: authorId, name: "Sample Author" }
    return {
      id: 'new-' + Date.now(),
      name,
      description,
      author,
    }
  },
})