"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isIntentRequest = exports.IntentRequestDTO = exports.IntentRequestPayloadDTO = exports.IntentRequestEntityDTO = exports.VerboseValueDTO = void 0;
const zod_1 = require("zod");
const payload_dto_1 = require("../payload.dto");
const request_type_enum_1 = require("../request-type.enum");
const utils_dto_1 = require("../utils.dto");
exports.VerboseValueDTO = zod_1.z.object({
    rawText: zod_1.z.string(),
    canonicalText: zod_1.z.string(),
    startIndex: zod_1.z.number(),
});
exports.IntentRequestEntityDTO = zod_1.z
    .object({
    name: zod_1.z.string(),
    value: zod_1.z.string(),
    query: zod_1.z.string().optional(),
    verboseValue: zod_1.z.array(exports.VerboseValueDTO).optional(),
})
    .passthrough();
exports.IntentRequestPayloadDTO = payload_dto_1.ActionAndLabelRequestPayloadDTO.extend({
    data: zod_1.z.record(zod_1.z.any()).optional(),
    query: zod_1.z.string().default(''),
    entities: zod_1.z.array(exports.IntentRequestEntityDTO).default([]),
    intent: zod_1.z.object({ name: zod_1.z.string() }).passthrough(),
    confidence: zod_1.z.number().optional(),
}).passthrough();
exports.IntentRequestDTO = utils_dto_1.BaseRequestDTO.extend({
    type: zod_1.z.literal(request_type_enum_1.RequestType.INTENT),
    payload: exports.IntentRequestPayloadDTO,
}).passthrough();
const isIntentRequest = (value) => {
    const parsedResult = exports.IntentRequestDTO.safeParse(value);
    return (parsedResult.success &&
        // Need to explicitly check that optional properties with default values exist before
        // Zod transforms the input data. When Zod transforms data with a `.default()` tag
        // it inserts the default value before validating that the value matches the type.
        //
        // This is problematic in use-cases where we use Zod purely as a type-guard, in which
        // case, we discard the parsed object and instead use the original object which does
        // not have default values injected, thus, creating a misleading type-guard.
        !!value &&
        typeof value === 'object' &&
        'payload' in value &&
        !!value.payload &&
        typeof value.payload === 'object' &&
        'entities' in value.payload &&
        'query' in value.payload);
};
exports.isIntentRequest = isIntentRequest;
//# sourceMappingURL=intent-request.dto.js.map