import {
  __commonJS
} from "./chunk-V4OQ3NZ2.js";

// ../../node_modules/@trigo/fsm/lib/to-camel-case.js
var require_to_camel_case = __commonJS({
  "../../node_modules/@trigo/fsm/lib/to-camel-case.js"(exports, module) {
    "use strict";
    module.exports = (str) => {
      const words = str.split(/[_-]|:/);
      let result = words[0];
      for (let n = 1; n < words.length; n++) {
        result = result + words[n].charAt(0).toUpperCase() + words[n].substring(1);
      }
      return result;
    };
  }
});

// ../../node_modules/@trigo/fsm/lib/is-valid-state-value.js
var require_is_valid_state_value = __commonJS({
  "../../node_modules/@trigo/fsm/lib/is-valid-state-value.js"(exports, module) {
    "use strict";
    var STATE_KEY_REGEX = /^([a-zA-Z0-9-_.#/@$%^!=<>+~?]+|\*)$/;
    module.exports = (value) => value.match(STATE_KEY_REGEX);
  }
});

// ../../node_modules/@trigo/fsm/lib/composit-state.js
var require_composit_state = __commonJS({
  "../../node_modules/@trigo/fsm/lib/composit-state.js"(exports, module) {
    "use strict";
    var isValidStateValue = require_is_valid_state_value();
    var parse = (state) => {
      const obj = {};
      state.split("|").forEach((part) => {
        const keyVal = part.split(":");
        obj[keyVal[0]] = keyVal[1];
      });
      return obj;
    };
    var build = (options) => {
      const states = [];
      Object.keys(options).forEach((key) => {
        if (!isValidStateValue(options[key])) {
          throw new Error(`Invalid state value! from: ${options[key]}`);
        }
        states.push(`${key}:${options[key]}`);
      });
      return states.sort().join("|");
    };
    var CompositState = class {
      /**
       * Build a state string from a javascript object
       *
       * @param {object} stateObj the state object
       *
       * @return {string} the string representation of the object
       */
      static build(stateObj) {
        return build(stateObj);
      }
      /**
       * Build a state string from a javascript object
       *
       * @param {string} state the string representation of the object
       *
       * @return {object} the state object
       */
      static parse(state) {
        return parse(state);
      }
    };
    module.exports = CompositState;
  }
});

// ../../node_modules/@trigo/fsm/lib/parse-transition.js
var require_parse_transition = __commonJS({
  "../../node_modules/@trigo/fsm/lib/parse-transition.js"(exports, module) {
    "use strict";
    var isValidStateValue = require_is_valid_state_value();
    var validateFromTo = (fromTo) => {
      const froms = Array.isArray(fromTo) ? fromTo : [fromTo];
      froms.forEach((from) => {
        if (!from || typeof from === "string" && (!isValidStateValue(from) || from === "__uninitialized__")) {
          throw new Error(`Invalid state value! from: ${from}`);
        } else if (typeof from === "object") {
          Object.keys(from).forEach((fromKey) => {
            const fromVal = Array.isArray(from[fromKey]) ? from[fromKey] : [from[fromKey]];
            fromVal.forEach((val) => {
              if (typeof val === "string" && (!isValidStateValue(val) || from === "__uninitialized__")) {
                throw new Error(`Invalid state value! from: ${from}`);
              }
            });
          });
        }
      });
    };
    module.exports = (transition) => {
      const trans = Object.assign({}, transition);
      if (!trans.name || !trans.name.replace(/ /g, "") || trans.name === "__uninitialized__") {
        throw new Error(`Invalid transition name: ${trans.name}`);
      }
      validateFromTo(trans.from);
      validateFromTo(trans.to);
      return trans;
    };
  }
});

// ../../node_modules/@trigo/fsm/lib/find-possible-transitions.js
var require_find_possible_transitions = __commonJS({
  "../../node_modules/@trigo/fsm/lib/find-possible-transitions.js"(exports, module) {
    "use strict";
    var compositState = require_composit_state();
    var matchObjects = (stateObj, fromObj) => {
      const stateKeys = Object.keys(stateObj);
      for (const stateKey of stateKeys) {
        if (!fromObj[stateKey]) return false;
        const stateKeyValue = stateObj[stateKey];
        const fromValues = Array.isArray(fromObj[stateKey]) ? fromObj[stateKey] : [fromObj[stateKey]];
        if (fromValues.indexOf(stateKeyValue) === -1) return false;
      }
      return true;
    };
    var matchState = (state, trans) => {
      if (trans.from === "*") return true;
      const froms = Array.isArray(trans.from) ? trans.from : [trans.from];
      if (state.indexOf(":") === -1) {
        return froms.indexOf(state) !== -1;
      }
      const stateObj = compositState.parse(state);
      for (const from of froms) {
        if (typeof from === "object") {
          if (matchObjects(stateObj, from)) return true;
        }
      }
      return false;
    };
    module.exports = (state, transitions) => transitions.filter((t) => matchState(state, t));
  }
});

// ../../node_modules/@trigo/fsm/lib/find-current-transition.js
var require_find_current_transition = __commonJS({
  "../../node_modules/@trigo/fsm/lib/find-current-transition.js"(exports, module) {
    "use strict";
    var toCamelCase = require_to_camel_case();
    var findPossibleTransitions = require_find_possible_transitions();
    module.exports = (transitionName, state, transitions) => {
      const matches = findPossibleTransitions(state, transitions.filter((t) => toCamelCase(t.name) === transitionName));
      if (matches.length > 1) {
        throw new Error(`Ambigious transitions found: ${matches.map((m) => JSON.stringify(m)).join(" ")}`);
      }
      return matches[0];
    };
  }
});

// ../../node_modules/@trigo/fsm/lib/get-all-taken-names.js
var require_get_all_taken_names = __commonJS({
  "../../node_modules/@trigo/fsm/lib/get-all-taken-names.js"(exports, module) {
    "use strict";
    module.exports = (obj) => {
      const methods = /* @__PURE__ */ new Set();
      while (obj = Reflect.getPrototypeOf(obj)) {
        const keys = Reflect.ownKeys(obj);
        keys.forEach((k) => methods.add(k));
      }
      return methods;
    };
  }
});

// ../../node_modules/@trigo/fsm/lib/execute-transition-rules.js
var require_execute_transition_rules = __commonJS({
  "../../node_modules/@trigo/fsm/lib/execute-transition-rules.js"(exports, module) {
    "use strict";
    module.exports = (transitionRules, ctx) => {
      const rules = Array.isArray(transitionRules) ? transitionRules : [transitionRules];
      for (const rule of rules) {
        if (rule) {
          try {
            rule(ctx);
          } catch (e) {
            return e;
          }
        }
      }
      return void 0;
    };
  }
});

// ../../node_modules/@trigo/fsm/lib/parse-transition-api.js
var require_parse_transition_api = __commonJS({
  "../../node_modules/@trigo/fsm/lib/parse-transition-api.js"(exports, module) {
    "use strict";
    var executeTransitionRules = require_execute_transition_rules();
    function getNested(theObject, path) {
      try {
        const separator = ".";
        return path.replace("[", separator).replace("]", "").split(separator).reduce(
          (obj, property) => obj[property],
          theObject
        );
      } catch (err) {
        return void 0;
      }
    }
    var replaceFromParams = (path, params, ctx, error) => {
      let href = path;
      Object.keys(params).forEach((key) => {
        const value = getNested(ctx, params[key]);
        if (value === void 0 && !error) {
          throw new Error(`Cannot resolve param: "${key}" data path: "${params[key]}"`);
        }
        if (value !== void 0) {
          href = href.replace(new RegExp(`{${key}}`, "g"), value);
        }
      });
      return href;
    };
    var extractParams = (path) => {
      const matches = path.match(/\{.*?\}/g);
      if (!matches) return void 0;
      const params = {};
      matches.forEach((m) => {
        params[m.replace(/\{/, "").replace(/\}/, "")] = true;
      });
      return params;
    };
    module.exports = ({ api, ctx, rules }) => {
      if (!api) throw new Error('Argument "api" missing');
      if (!api.path) throw new Error('Argument "api.path" missing');
      const method = api.method || "get";
      const transitionRules = rules || [];
      const error = executeTransitionRules(transitionRules, ctx);
      let href = api.path;
      if (ctx && ctx.api && ctx.api.params) {
        href = replaceFromParams(href, ctx.api.params, ctx, error);
      }
      if (api.params) {
        href = replaceFromParams(href, api.params, ctx, error);
      }
      const params = extractParams(href);
      const link = {
        href,
        method
      };
      if (params) {
        link.params = params;
      }
      if (error) {
        link.error = { message: error.message };
      }
      return link;
    };
  }
});

// ../../node_modules/@trigo/fsm/lib/fsm.js
var require_fsm = __commonJS({
  "../../node_modules/@trigo/fsm/lib/fsm.js"(exports, module) {
    "use strict";
    var toCamelCase = require_to_camel_case();
    var compositState = require_composit_state();
    var parseTrasition = require_parse_transition();
    var findCurrentTransition = require_find_current_transition();
    var findPossibleTransitions = require_find_possible_transitions();
    var getAllTakenNames = require_get_all_taken_names();
    var parseTrasitionApi = require_parse_transition_api();
    var executeTransitionRules = require_execute_transition_rules();
    var isValidStateValue = require_is_valid_state_value();
    var callIfSet = async (handler, ctx, args) => {
      if (handler && typeof handler === "function") {
        const a = [ctx].concat(args);
        return handler(...a);
      }
      return null;
    };
    var FSM = class _FSM {
      /**
       * Returns the composit state tool used to parse and build state strings from objects
       *
       * @return {CompositState} the composit sate tool
       */
      static get compositState() {
        return compositState;
      }
      /**
       * Create a camelCase function name formthe given string. Used internally to convert transition names to function names
       *
       * @param {string} name the name to transform
       *
       * @return {string} camelCased version of the given name
       */
      static toFunctionName(name) {
        return toCamelCase(name);
      }
      /**
          * Create a new state machine.
          * @param {object} options the initalisation object.
          * @param {object} options.initialState the state string used to initialize the state machine
          * @param {Array.<object>} options.transitions array of defined transitions
          * @param {object} options.data the data that is stored in the state machine
          * @param {function} options.saveState function with signature `async (ctx, arg1, arg2...) => {...}`
          * @param {function} options.willChangeState function with signature `async (ctx, arg1, arg2...) => {...}`
          * @param {function} options.didChangeState function with signature `async (ctx, arg1, arg2...) => {...}`
          * @param {function} options.willSaveState function with signature `async (ctx, arg1, arg2...) => {...}`
          * @param {function} options.didSaveState function with signature `async (ctx, arg1, arg2...) => {...}`
          * @param {object} options.eventHandler object containin hander for specific trasaction
       *	```
       *	{
       *		beforeTransName: async (ctx, args) => {...},
       *		afterTransName: async (ctx, args) => {...},
       *	}
       *	```
       * @param {object} options.api object containing global REST API data:
       *	```
       *	{
       *		self: {
       *			path: '/{entityName}/{id}'
       *		},
       *		params: {
       *			id: 'data.event.id',
       *			entityName: 'api.data.entityName'
       *		},
       *		data: {
       *			entityName: 'events'
       *		}
       *	}
       *	```
          */
      constructor({ initialState, transitions, data, saveState, willChangeState, didChangeState, willSaveState, didSaveState, eventHandler, api }) {
        this._state = "__uninitialized__";
        this._transitions = [];
        this._saveState = saveState;
        this._willChangeState = willChangeState;
        this._didChangeState = didChangeState;
        this._willSaveState = willSaveState;
        this._didSaveState = didSaveState;
        this._data = data;
        this._eventHandler = eventHandler || {};
        this._trasitionFunctionNames = [];
        this._api = api || {};
        if (transitions) {
          this.addTransition(transitions);
        }
        if (initialState) {
          this.init(initialState);
        }
      }
      /**
       * Initalize an existing state machine with the given state
       *
       * @param {string} state the state string to set. The string must be one of the existing
       * states of the state machine
       */
      init(state) {
        this._state = state;
        return this;
      }
      /**
       * Get the current state string
       *
       * @return {string} the state string
       */
      get state() {
        return this._state;
      }
      /**
       * @private
       */
      set state(_) {
        throw new Error("cannot set state");
      }
      /**
       * Get the data stored in the state machine
       *
       * @return {object} the stored data objec
       */
      get data() {
        return this._data;
      }
      /**
       * Set the data stored in the state machine
       *
       * @param {object} value the data object
       */
      set data(value) {
        this._data = value;
      }
      /**
       * Get all transitions that are valid for the current state of the state machine
       *
       * @return {Array.<string>} array of valid transitions name
       */
      transitions() {
        return findPossibleTransitions(this.state, this._transitions).map((t) => t.name);
      }
      /**
       * Get all transititons that are defined for the state machine in the format
       * ```javascript
       * [
       *	 { name: 'a-to-b', from: 'a', to: 'b' },
       *	 { name: 'no:op', from: 'a', to: '*' },
       *	 { name: 'b-to-c', from: 'b', to: 'c' },
       * ]
       * }```
       * @return {Array.<object>} transitions
       */
      allTransitions() {
        return this._transitions.map((t) => Object.assign({}, t));
      }
      /**
       * Get rest API links for all currently available transitions where defined
       * ```javascript
       * // example output:
       * {
       *		self: {
       *			href: '/events/42',
       *			method: 'get'
       *		},
       *		'transition:name:1': {
       *			href: '/events/42/transition/{param1}',
       *			method: 'put',
       *			params: {
       *				param1: true,
       *			}
       *		}
       * }
       * ```
       * @return {object} "restApi" object.
       */
      restApi() {
        const api = {};
        if (this._api && this._api.self) {
          api.self = parseTrasitionApi({
            api: this._api.self,
            ctx: {
              data: this._data,
              api: this._api
            }
          });
        }
        findPossibleTransitions(this.state, this._transitions).filter((t) => t.api).forEach((t) => {
          api[t.name] = parseTrasitionApi({
            api: t.api,
            ctx: {
              data: this._data,
              api: this._api
            },
            rules: t.rules
          });
        });
        return api;
      }
      /**
       * Execute a transition
       *
       * @param {string} transition the name of the transition
       * @param {...any} args list of arguments passed to the event handlers during transition
       *
       * @return {object} object containing the results of the executed event handlers
       */
      execute(transition, ...args) {
        return this[_FSM.toFunctionName(transition)](...args);
      }
      /**
       * Add a new transition to the state machine
       *
       * @param {object} transition the name of the transition<br><br>
       * Suported syntax: (camelCasle, colon:case, snake_case, dash-case)<br>
       * myTransition, my:transition, my_transition, my-transition => will create function .myTransition()
       * @param {string} transition.name the name of the transition
       * @param {(string|object|Array.<string>|Array.<object>)} transition.form the states from which this
       * transition can be triggered.<br><br>
       * Supported syntax:
       * ```
       * '*' => allow from any state
       * 'state1' => allow only from state 'state1'
       * ['state1', 'state2'] => allow transition from state1 & state2
       * { state: ['s1', 's2'], substate: ['sub1', 'sub2'] } => allow transition
       * from all states creates by calculating all
       * permutations of the given states. 'state:s2|substate:sub1'
       * 'state:s2|substate:sub1' and 'state:s2|substate:sub2'
       * ```
       * @param {(string|object|function} transition.to defines the state that is created after the transition<br><br>
       * Supported syntax:
       * ```javascript
       * '*' => do not change source state
       * 'state1' => sets target state to 'state1'
       * { state: 's1' } => sets the property "state" of the current state
       * to "s1" eg. patches the existing state object representation
       * async (state, ctx) -> String => stets state from result of the function
       * { state: async (state, ctx) -> String } => stets substate from result of the function
       * the result of the function mus be a vaild state string value
       * ```
       */
      addTransition(transition) {
        const transitions = Array.isArray(transition) ? transition : [transition];
        transitions.map(parseTrasition).forEach((trans) => {
          if (this._trasitionFunctionNames.indexOf(_FSM.toFunctionName(trans.name)) !== -1) {
            const conflicting = this._trasitionFunctionNames[this._trasitionFunctionNames.indexOf(_FSM.toFunctionName(trans.name))];
            throw new Error(`Ambigious transtion name: "${trans.name}" conflicts with existing transition: "${conflicting}"`);
          }
          if (getAllTakenNames(this).has(_FSM.toFunctionName(trans.name))) {
            throw new Error(`Forbidden transition name: "${trans.name}" forbidden names: "${Array.from(getAllTakenNames(this)).join(", ")}"`);
          }
          this._trasitionFunctionNames.push(_FSM.toFunctionName(trans.name));
          this._transitions.push(trans);
          this._buildTransition(trans);
        });
        return this;
      }
      _buildTransition(trans) {
        const transitionName = toCamelCase(trans.name);
        if (this[transitionName]) return;
        this[transitionName] = async (...args) => {
          if (this.__inTransition) {
            throw new Error("Cannot start transition when during running transition");
          }
          this.__inTransition = true;
          try {
            const currentTransition = findCurrentTransition(transitionName, this.state, this._transitions);
            const validNames = this.transitions().map(toCamelCase);
            if (!currentTransition || validNames.indexOf("*") === -1 && validNames.indexOf(transitionName) === -1) {
              throw new Error(`Invalid transition: "${transitionName}" in state: "${this.state}"`);
            }
            const from = this.state;
            let to = from;
            const ctx = {
              transition: transitionName,
              from,
              fsm: this
            };
            if (this._data) {
              ctx.data = this._data;
            }
            const execTransitionFunction = async (fn, state, ctxArg) => {
              const res = await fn(state, ctxArg);
              if (!isValidStateValue(res)) {
                throw new Error(`Invalid "to" function result: "${res}" not a valid state string`);
              }
              return res;
            };
            if (currentTransition.to !== "*") {
              if (typeof currentTransition.to === "function") {
                to = await execTransitionFunction(currentTransition.to, from, ctx);
              } else if (typeof currentTransition.to === "string") {
                to = currentTransition.to;
              } else if (typeof currentTransition.to === "object") {
                const stateObj = _FSM.compositState.parse(from);
                const newStateObj = Object.assign({}, stateObj, currentTransition.to);
                for (const key of Object.keys(currentTransition.to)) {
                  if (typeof currentTransition.to[key] === "function") {
                    newStateObj[key] = await execTransitionFunction(currentTransition.to[key], stateObj[key], ctx);
                  } else {
                    newStateObj[key] = currentTransition.to[key];
                  }
                }
                to = _FSM.compositState.build(newStateObj);
              }
            }
            ctx.to = to;
            const rules = currentTransition.rules || [];
            const error = executeTransitionRules(rules, ctx);
            if (error) {
              const newError = new Error(`Invalid transition: "${transitionName}". Reason: ${error.message}`);
              newError.inner = error;
              throw newError;
            }
            const beforeHandler = `before${transitionName[0].toUpperCase()}${transitionName.substring(1)}`;
            const afterHandler = `after${transitionName[0].toUpperCase()}${transitionName.substring(1)}`;
            const result = {};
            ctx.results = result;
            result.willChangeState = await callIfSet(this._willChangeState, ctx, args);
            ctx.results = Object.assign({}, result);
            result[beforeHandler] = await callIfSet(this._eventHandler[beforeHandler], ctx, args);
            this._state = to;
            ctx.results = Object.assign({}, result);
            result.didChangeState = await callIfSet(this._didChangeState, ctx, args);
            if (this._saveState && typeof this._saveState === "function") {
              ctx.results = Object.assign({}, result);
              result.willSaveState = await callIfSet(this._willSaveState, ctx, args);
              ctx.results = Object.assign({}, result);
              result.saveState = await this._saveState(ctx, args);
              ctx.results = Object.assign({}, result);
              result.didSaveState = await callIfSet(this._didSaveState, ctx, args);
            }
            ctx.results = Object.assign({}, result);
            result[afterHandler] = await callIfSet(this._eventHandler[afterHandler], ctx, args);
            this.__inTransition = false;
            return result;
          } catch (e) {
            this.__inTransition = false;
            throw e;
          }
        };
      }
    };
    module.exports = FSM;
  }
});

// ../../node_modules/@trigo/fsm/index.js
var require_fsm2 = __commonJS({
  "../../node_modules/@trigo/fsm/index.js"(exports, module) {
    module.exports = require_fsm();
  }
});
export default require_fsm2();
//# sourceMappingURL=@trigo_fsm.js.map
