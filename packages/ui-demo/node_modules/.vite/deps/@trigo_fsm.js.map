{
  "version": 3,
  "sources": ["../../../../../node_modules/@trigo/fsm/lib/to-camel-case.js", "../../../../../node_modules/@trigo/fsm/lib/is-valid-state-value.js", "../../../../../node_modules/@trigo/fsm/lib/composit-state.js", "../../../../../node_modules/@trigo/fsm/lib/parse-transition.js", "../../../../../node_modules/@trigo/fsm/lib/find-possible-transitions.js", "../../../../../node_modules/@trigo/fsm/lib/find-current-transition.js", "../../../../../node_modules/@trigo/fsm/lib/get-all-taken-names.js", "../../../../../node_modules/@trigo/fsm/lib/execute-transition-rules.js", "../../../../../node_modules/@trigo/fsm/lib/parse-transition-api.js", "../../../../../node_modules/@trigo/fsm/lib/fsm.js", "../../../../../node_modules/@trigo/fsm/index.js"],
  "sourcesContent": ["'use strict';\n\n/** @private */\nmodule.exports = (str) => {\n\tconst words = str.split(/[_-]|:/);\n\tlet result = words[0];\n\tfor (let n = 1; n < words.length; n++) {\n\t\tresult = result + words[n].charAt(0).toUpperCase() + words[n].substring(1);\n\t}\n\treturn result;\n};\n", "'use strict';\n\nconst STATE_KEY_REGEX = /^([a-zA-Z0-9-_.#/@$%^!=<>+~?]+|\\*)$/;\n\n/** @private */\nmodule.exports = value => value.match(STATE_KEY_REGEX);\n", "'use strict';\n\nconst isValidStateValue = require('./is-valid-state-value');\n\nconst parse = (state) => {\n\tconst obj = {};\n\tstate.split('|').forEach((part) => {\n\t\tconst keyVal = part.split(':');\n\t\tobj[keyVal[0]] = keyVal[1];\n\t});\n\treturn obj;\n};\n\nconst build = (options) => {\n\tconst states = [];\n\tObject.keys(options).forEach((key) => {\n\t\tif (!isValidStateValue(options[key])) {\n\t\t\tthrow new Error(`Invalid state value! from: ${options[key]}`);\n\t\t}\n\t\tstates.push(`${key}:${options[key]}`);\n\t});\n\treturn states.sort().join('|');\n};\n\n/**\n *\n * Class to build, parse and manipulate composit states<br>\n *\n * State object in FSM are converted to string using this class<br>\n * The state object { a: 'val1', b: 'val2', c: 'val3' } is internaly stored<br>\n * in its string repreentation: \"a:val1|b:val2|c:val3\"\n *\n * This utillity class is available from {@link FSM#compositState} property\n *\n * @class\n */\nclass CompositState {\n\t/**\n\t * Build a state string from a javascript object\n\t *\n\t * @param {object} stateObj the state object\n\t *\n\t * @return {string} the string representation of the object\n\t */\n\tstatic build(stateObj) {\n\t\treturn build(stateObj);\n\t}\n\n\t/**\n\t * Build a state string from a javascript object\n\t *\n\t * @param {string} state the string representation of the object\n\t *\n\t * @return {object} the state object\n\t */\n\tstatic parse(state) {\n\t\treturn parse(state);\n\t}\n}\n\nmodule.exports = CompositState;\n", "'use strict';\n\nconst isValidStateValue = require('./is-valid-state-value');\n\nconst validateFromTo = (fromTo) => {\n\tconst froms = Array.isArray(fromTo) ? fromTo : [fromTo];\n\tfroms.forEach((from) => {\n\t\tif (!from || (typeof from === 'string' && (!isValidStateValue(from) || from === '__uninitialized__'))) {\n\t\t\tthrow new Error(`Invalid state value! from: ${from}`);\n\t\t} else if (typeof from === 'object') {\n\t\t\tObject.keys(from).forEach((fromKey) => {\n\t\t\t\tconst fromVal = Array.isArray(from[fromKey]) ? from[fromKey] : [from[fromKey]];\n\t\t\t\tfromVal.forEach((val) => {\n\t\t\t\t\tif ((typeof val === 'string') && (!isValidStateValue(val) || from === '__uninitialized__')) {\n\t\t\t\t\t\tthrow new Error(`Invalid state value! from: ${from}`);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t});\n};\n\n/** @private */\nmodule.exports = (transition) => {\n\tconst trans = Object.assign({}, transition);\n\tif (!trans.name || !trans.name.replace(/ /g, '') || trans.name === '__uninitialized__') {\n\t\tthrow new Error(`Invalid transition name: ${trans.name}`);\n\t}\n\tvalidateFromTo(trans.from);\n\tvalidateFromTo(trans.to);\n\n\treturn trans;\n};\n", "'use strict';\n\nconst compositState = require('./composit-state');\n\nconst matchObjects = (stateObj, fromObj) => {\n\tconst stateKeys = Object.keys(stateObj);\n\tfor (const stateKey of stateKeys) {\n\t\tif (!fromObj[stateKey]) return false;\n\t\tconst stateKeyValue = stateObj[stateKey];\n\t\tconst fromValues = Array.isArray(fromObj[stateKey]) ? fromObj[stateKey] : [fromObj[stateKey]];\n\t\tif (fromValues.indexOf(stateKeyValue) === -1) return false;\n\t}\n\treturn true;\n};\n\n\nconst matchState = (state, trans) => {\n\tif (trans.from === '*') return true;\n\tconst froms = Array.isArray(trans.from) ? trans.from : [trans.from];\n\tif (state.indexOf(':') === -1) {\n\t\treturn froms.indexOf(state) !== -1;\n\t}\n\n\n\tconst stateObj = compositState.parse(state);\n\n\tfor (const from of froms) {\n\t\tif (typeof from === 'object') {\n\t\t\tif (matchObjects(stateObj, from)) return true;\n\t\t}\n\t}\n\treturn false;\n};\n\n/** @private */\nmodule.exports = (state, transitions) => transitions.filter(t => matchState(state, t));\n", "'use strict';\n\nconst toCamelCase = require('./to-camel-case');\nconst findPossibleTransitions = require('./find-possible-transitions');\n\n/** @private */\nmodule.exports = (transitionName, state, transitions) => {\n\tconst matches = findPossibleTransitions(state, transitions.filter(t => toCamelCase(t.name) === transitionName));\n\n\tif (matches.length > 1) {\n\t\tthrow new Error(`Ambigious transitions found: ${matches.map(m => JSON.stringify(m)).join(' ')}`);\n\t}\n\treturn matches[0];\n};\n", "'use strict';\n\n/** @private */\nmodule.exports = (obj) => {\n\tconst methods = new Set();\n\twhile (obj = Reflect.getPrototypeOf(obj)) { // eslint-disable-line\n\t\tconst keys = Reflect.ownKeys(obj);\n\t\tkeys.forEach(k => methods.add(k));\n\t}\n\treturn methods;\n};\n", "'use strict';\n\n/** @private */\nmodule.exports = (transitionRules, ctx) => {\n\tconst rules = Array.isArray(transitionRules) ? transitionRules : [transitionRules];\n\n\tfor (const rule of rules) {\n\t\tif (rule) {\n\t\t\ttry { rule(ctx); } catch (e) {\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn undefined;\n};\n", "'use strict';\n\nconst executeTransitionRules = require('./execute-transition-rules');\n\nfunction getNested(theObject, path) {\n\ttry {\n\t\tconst separator = '.';\n\n\t\treturn path\n\t\t\t.replace('[', separator).replace(']', '')\n\t\t\t.split(separator)\n\t\t\t.reduce(\n\t\t\t\t(obj, property) => obj[property], theObject,\n\t\t\t);\n\t} catch (err) {\n\t\treturn undefined;\n\t}\n}\n\nconst replaceFromParams = (path, params, ctx, error) => {\n\tlet href = path;\n\tObject.keys(params).forEach((key) => {\n\t\tconst value = getNested(ctx, params[key]);\n\t\tif (value === undefined && !error) {\n\t\t\tthrow new Error(`Cannot resolve param: \"${key}\" data path: \"${params[key]}\"`);\n\t\t}\n\t\tif (value !== undefined) {\n\t\t\thref = href.replace(new RegExp(`{${key}}`, 'g'), value);\n\t\t}\n\t});\n\n\treturn href;\n};\n\nconst extractParams = (path) => {\n\tconst matches = path.match(/\\{.*?\\}/g);\n\tif (!matches) return undefined;\n\tconst params = {};\n\tmatches.forEach((m) => {\n\t\tparams[m.replace(/\\{/, '').replace(/\\}/, '')] = true;\n\t});\n\treturn params;\n};\n\n/** @private */\nmodule.exports = ({ api, ctx, rules }) => {\n\tif (!api) throw new Error('Argument \"api\" missing');\n\tif (!api.path) throw new Error('Argument \"api.path\" missing');\n\tconst method = api.method || 'get';\n\n\tconst transitionRules = rules || [];\n\tconst error = executeTransitionRules(transitionRules, ctx);\n\n\tlet href = api.path;\n\tif (ctx && ctx.api && ctx.api.params) {\n\t\thref = replaceFromParams(href, ctx.api.params, ctx, error);\n\t}\n\tif (api.params) {\n\t\thref = replaceFromParams(href, api.params, ctx, error);\n\t}\n\n\tconst params = extractParams(href);\n\n\tconst link = {\n\t\thref,\n\t\tmethod,\n\t};\n\n\tif (params) {\n\t\tlink.params = params;\n\t}\n\n\tif (error) {\n\t\tlink.error = { message: error.message };\n\t}\n\n\treturn link;\n};\n", "'use strict';\n\n/* eslint no-unused-expressions: 0, class-methods-use-this: 0 */\n\nconst toCamelCase = require('./to-camel-case');\nconst compositState = require('./composit-state');\nconst parseTrasition = require('./parse-transition');\nconst findCurrentTransition = require('./find-current-transition');\nconst findPossibleTransitions = require('./find-possible-transitions');\nconst getAllTakenNames = require('./get-all-taken-names');\nconst parseTrasitionApi = require('./parse-transition-api');\nconst executeTransitionRules = require('./execute-transition-rules');\nconst isValidStateValue = require('./is-valid-state-value');\n\nconst callIfSet = async (handler, ctx, args) => {\n\tif (handler && typeof handler === 'function') {\n\t\tconst a = [ctx].concat(args);\n\t\treturn handler(...a);\n\t}\n\treturn null;\n};\n\n/**\n * Class representing a Finite State Machine\n * @class\n */\nclass FSM {\n\t/**\n\t * Returns the composit state tool used to parse and build state strings from objects\n\t *\n\t * @return {CompositState} the composit sate tool\n\t */\n\tstatic get compositState() {\n\t\treturn compositState;\n\t}\n\n\t/**\n\t * Create a camelCase function name formthe given string. Used internally to convert transition names to function names\n\t *\n\t * @param {string} name the name to transform\n\t *\n\t * @return {string} camelCased version of the given name\n\t */\n\tstatic toFunctionName(name) {\n\t\treturn toCamelCase(name);\n\t}\n\n\t/**\n     * Create a new state machine.\n     * @param {object} options the initalisation object.\n     * @param {object} options.initialState the state string used to initialize the state machine\n     * @param {Array.<object>} options.transitions array of defined transitions\n     * @param {object} options.data the data that is stored in the state machine\n     * @param {function} options.saveState function with signature `async (ctx, arg1, arg2...) => {...}`\n     * @param {function} options.willChangeState function with signature `async (ctx, arg1, arg2...) => {...}`\n     * @param {function} options.didChangeState function with signature `async (ctx, arg1, arg2...) => {...}`\n     * @param {function} options.willSaveState function with signature `async (ctx, arg1, arg2...) => {...}`\n     * @param {function} options.didSaveState function with signature `async (ctx, arg1, arg2...) => {...}`\n     * @param {object} options.eventHandler object containin hander for specific trasaction\n\t *\t```\n\t *\t{\n\t *\t\tbeforeTransName: async (ctx, args) => {...},\n\t *\t\tafterTransName: async (ctx, args) => {...},\n\t *\t}\n\t *\t```\n\t * @param {object} options.api object containing global REST API data:\n\t *\t```\n\t *\t{\n\t *\t\tself: {\n\t *\t\t\tpath: '/{entityName}/{id}'\n\t *\t\t},\n\t *\t\tparams: {\n\t *\t\t\tid: 'data.event.id',\n\t *\t\t\tentityName: 'api.data.entityName'\n\t *\t\t},\n\t *\t\tdata: {\n\t *\t\t\tentityName: 'events'\n\t *\t\t}\n\t *\t}\n\t *\t```\n     */\n\tconstructor({ initialState, transitions, data, saveState, willChangeState, didChangeState, willSaveState, didSaveState, eventHandler, api }) {\n\t\tthis._state = '__uninitialized__';\n\t\tthis._transitions = [];\n\t\tthis._saveState = saveState;\n\t\tthis._willChangeState = willChangeState;\n\t\tthis._didChangeState = didChangeState;\n\t\tthis._willSaveState = willSaveState;\n\t\tthis._didSaveState = didSaveState;\n\t\tthis._data = data;\n\t\tthis._eventHandler = eventHandler || {};\n\t\tthis._trasitionFunctionNames = [];\n\t\tthis._api = api || {};\n\n\t\tif (transitions) {\n\t\t\tthis.addTransition(transitions);\n\t\t}\n\n\t\tif (initialState) {\n\t\t\tthis.init(initialState);\n\t\t}\n\t}\n\n\t/**\n\t * Initalize an existing state machine with the given state\n\t *\n\t * @param {string} state the state string to set. The string must be one of the existing\n\t * states of the state machine\n\t */\n\tinit(state) {\n\t\tthis._state = state;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the current state string\n\t *\n\t * @return {string} the state string\n\t */\n\tget state() {\n\t\treturn this._state;\n\t}\n\n\t/**\n\t * @private\n\t */\n\tset state(_) {\n\t\tthrow new Error('cannot set state');\n\t}\n\n\t/**\n\t * Get the data stored in the state machine\n\t *\n\t * @return {object} the stored data objec\n\t */\n\tget data() {\n\t\treturn this._data;\n\t}\n\n\t/**\n\t * Set the data stored in the state machine\n\t *\n\t * @param {object} value the data object\n\t */\n\tset data(value) {\n\t\tthis._data = value;\n\t}\n\n\t/**\n\t * Get all transitions that are valid for the current state of the state machine\n\t *\n\t * @return {Array.<string>} array of valid transitions name\n\t */\n\ttransitions() {\n\t\treturn findPossibleTransitions(this.state, this._transitions).map(t => t.name);\n\t}\n\n\t/**\n\t * Get all transititons that are defined for the state machine in the format\n\t * ```javascript\n\t * [\n\t *\t { name: 'a-to-b', from: 'a', to: 'b' },\n\t *\t { name: 'no:op', from: 'a', to: '*' },\n\t *\t { name: 'b-to-c', from: 'b', to: 'c' },\n\t * ]\n\t * }```\n\t * @return {Array.<object>} transitions\n\t */\n\tallTransitions() {\n\t\treturn this._transitions.map(t => Object.assign({}, t));\n\t}\n\n\t/**\n\t * Get rest API links for all currently available transitions where defined\n\t * ```javascript\n\t * // example output:\n\t * {\n\t *\t\tself: {\n\t *\t\t\thref: '/events/42',\n\t *\t\t\tmethod: 'get'\n\t *\t\t},\n\t *\t\t'transition:name:1': {\n\t *\t\t\thref: '/events/42/transition/{param1}',\n\t *\t\t\tmethod: 'put',\n\t *\t\t\tparams: {\n\t *\t\t\t\tparam1: true,\n\t *\t\t\t}\n\t *\t\t}\n\t * }\n\t * ```\n\t * @return {object} \"restApi\" object.\n\t */\n\trestApi() {\n\t\tconst api = {};\n\t\tif (this._api && this._api.self) {\n\t\t\tapi.self = parseTrasitionApi({\n\t\t\t\tapi: this._api.self,\n\t\t\t\tctx: {\n\t\t\t\t\tdata: this._data,\n\t\t\t\t\tapi: this._api,\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\t\tfindPossibleTransitions(this.state, this._transitions)\n\t\t\t.filter(t => t.api)\n\t\t\t.forEach((t) => {\n\t\t\t\tapi[t.name] = parseTrasitionApi({\n\t\t\t\t\tapi: t.api,\n\t\t\t\t\tctx: {\n\t\t\t\t\t\tdata: this._data,\n\t\t\t\t\t\tapi: this._api,\n\t\t\t\t\t},\n\t\t\t\t\trules: t.rules,\n\t\t\t\t});\n\t\t\t});\n\n\t\treturn api;\n\t}\n\n\t/**\n\t * Execute a transition\n\t *\n\t * @param {string} transition the name of the transition\n\t * @param {...any} args list of arguments passed to the event handlers during transition\n\t *\n\t * @return {object} object containing the results of the executed event handlers\n\t */\n\texecute(transition, ...args) {\n\t\treturn this[FSM.toFunctionName(transition)](...args);\n\t}\n\n\n\t/**\n\t * Add a new transition to the state machine\n\t *\n\t * @param {object} transition the name of the transition<br><br>\n\t * Suported syntax: (camelCasle, colon:case, snake_case, dash-case)<br>\n\t * myTransition, my:transition, my_transition, my-transition => will create function .myTransition()\n\t * @param {string} transition.name the name of the transition\n\t * @param {(string|object|Array.<string>|Array.<object>)} transition.form the states from which this\n\t * transition can be triggered.<br><br>\n\t * Supported syntax:\n\t * ```\n\t * '*' => allow from any state\n\t * 'state1' => allow only from state 'state1'\n\t * ['state1', 'state2'] => allow transition from state1 & state2\n\t * { state: ['s1', 's2'], substate: ['sub1', 'sub2'] } => allow transition\n\t * from all states creates by calculating all\n\t * permutations of the given states. 'state:s2|substate:sub1'\n\t * 'state:s2|substate:sub1' and 'state:s2|substate:sub2'\n\t * ```\n\t * @param {(string|object|function} transition.to defines the state that is created after the transition<br><br>\n\t * Supported syntax:\n\t * ```javascript\n\t * '*' => do not change source state\n\t * 'state1' => sets target state to 'state1'\n\t * { state: 's1' } => sets the property \"state\" of the current state\n\t * to \"s1\" eg. patches the existing state object representation\n\t * async (state, ctx) -> String => stets state from result of the function\n\t * { state: async (state, ctx) -> String } => stets substate from result of the function\n\t * the result of the function mus be a vaild state string value\n\t * ```\n\t */\n\taddTransition(transition) {\n\t\tconst transitions = Array.isArray(transition) ? transition : [transition];\n\t\ttransitions.map(parseTrasition)\n\t\t\t.forEach((trans) => {\n\t\t\t\tif (this._trasitionFunctionNames.indexOf(FSM.toFunctionName(trans.name)) !== -1) {\n\t\t\t\t\tconst conflicting = this._trasitionFunctionNames[this._trasitionFunctionNames.indexOf(FSM.toFunctionName(trans.name))];\n\t\t\t\t\tthrow new Error(`Ambigious transtion name: \"${trans.name}\" conflicts with existing transition: \"${conflicting}\"`);\n\t\t\t\t}\n\t\t\t\tif (getAllTakenNames(this).has(FSM.toFunctionName(trans.name))) {\n\t\t\t\t\tthrow new Error(`Forbidden transition name: \"${trans.name}\" forbidden names: \"${Array.from(getAllTakenNames(this)).join(', ')}\"`);\n\t\t\t\t}\n\t\t\t\tthis._trasitionFunctionNames.push(FSM.toFunctionName(trans.name));\n\n\t\t\t\tthis._transitions.push(trans);\n\t\t\t\tthis._buildTransition(trans);\n\t\t\t});\n\t\treturn this;\n\t}\n\n\t_buildTransition(trans) {\n\t\tconst transitionName = toCamelCase(trans.name);\n\t\tif (this[transitionName]) return;\n\n\t\t/**\n\t\t * Run-time created transition methods\n\t\t *\n\t\t * @param {...any} args the arguments that will be passed to event handlers\n\t\t *\n\t\t * @return {object} contains the result objects from the event handlers\n\t\t */\n\t\tthis[transitionName] = async (...args) => {\n\t\t\tif (this.__inTransition) {\n\t\t\t\tthrow new Error('Cannot start transition when during running transition');\n\t\t\t}\n\t\t\tthis.__inTransition = true;\n\t\t\ttry {\n\t\t\t\tconst currentTransition = findCurrentTransition(transitionName, this.state, this._transitions);\n\t\t\t\tconst validNames = this.transitions().map(toCamelCase);\n\n\t\t\t\tif (!currentTransition || (validNames.indexOf('*') === -1 && validNames.indexOf(transitionName) === -1)) {\n\t\t\t\t\tthrow new Error(`Invalid transition: \"${transitionName}\" in state: \"${this.state}\"`);\n\t\t\t\t}\n\n\t\t\t\tconst from = this.state;\n\t\t\t\tlet to = from;\n\n\t\t\t\tconst ctx = {\n\t\t\t\t\ttransition: transitionName,\n\t\t\t\t\tfrom,\n\t\t\t\t\tfsm: this,\n\t\t\t\t};\n\t\t\t\tif (this._data) {\n\t\t\t\t\tctx.data = this._data;\n\t\t\t\t}\n\n\t\t\t\tconst execTransitionFunction = async (fn, state, ctxArg) => {\n\t\t\t\t\tconst res = await fn(state, ctxArg);\n\t\t\t\t\tif (!isValidStateValue(res)) {\n\t\t\t\t\t\tthrow new Error(`Invalid \"to\" function result: \"${res}\" not a valid state string`);\n\t\t\t\t\t}\n\t\t\t\t\treturn res;\n\t\t\t\t};\n\n\t\t\t\tif (currentTransition.to !== '*') {\n\t\t\t\t\tif (typeof currentTransition.to === 'function') {\n\t\t\t\t\t\tto = await execTransitionFunction(currentTransition.to, from, ctx);\n\t\t\t\t\t} else if (typeof currentTransition.to === 'string') {\n\t\t\t\t\t\tto = currentTransition.to;\n\t\t\t\t\t} else if (typeof currentTransition.to === 'object') {\n\t\t\t\t\t\tconst stateObj = FSM.compositState.parse(from);\n\t\t\t\t\t\tconst newStateObj = Object.assign({}, stateObj, currentTransition.to);\n\t\t\t\t\t\tfor (const key of Object.keys(currentTransition.to)) {\n\t\t\t\t\t\t\tif (typeof currentTransition.to[key] === 'function') {\n\t\t\t\t\t\t\t\tnewStateObj[key] = await execTransitionFunction(currentTransition.to[key], stateObj[key], ctx);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnewStateObj[key] = currentTransition.to[key];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tto = FSM.compositState.build(newStateObj);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tctx.to = to;\n\n\n\t\t\t\tconst rules = currentTransition.rules || [];\n\t\t\t\tconst error = executeTransitionRules(rules, ctx);\n\t\t\t\tif (error) {\n\t\t\t\t\tconst newError = new Error(`Invalid transition: \"${transitionName}\". Reason: ${error.message}`);\n\t\t\t\t\tnewError.inner = error;\n\t\t\t\t\tthrow newError;\n\t\t\t\t}\n\n\t\t\t\tconst beforeHandler = `before${transitionName[0].toUpperCase()}${transitionName.substring(1)}`;\n\t\t\t\tconst afterHandler = `after${transitionName[0].toUpperCase()}${transitionName.substring(1)}`;\n\n\t\t\t\tconst result = {};\n\t\t\t\tctx.results = result;\n\t\t\t\tresult.willChangeState = await callIfSet(this._willChangeState, ctx, args);\n\n\t\t\t\tctx.results = Object.assign({}, result);\n\t\t\t\tresult[beforeHandler] = await callIfSet(this._eventHandler[beforeHandler], ctx, args);\n\t\t\t\t// console.log(`Change state: \"${from}\" => \"${to}\"`)\n\t\t\t\tthis._state = to;\n\n\t\t\t\tctx.results = Object.assign({}, result);\n\t\t\t\tresult.didChangeState = await callIfSet(this._didChangeState, ctx, args);\n\n\t\t\t\tif (this._saveState && typeof this._saveState === 'function') {\n\t\t\t\t\tctx.results = Object.assign({}, result);\n\t\t\t\t\tresult.willSaveState = await callIfSet(this._willSaveState, ctx, args);\n\n\t\t\t\t\tctx.results = Object.assign({}, result);\n\t\t\t\t\tresult.saveState = await this._saveState(ctx, args);\n\n\t\t\t\t\tctx.results = Object.assign({}, result);\n\t\t\t\t\tresult.didSaveState = await callIfSet(this._didSaveState, ctx, args);\n\t\t\t\t}\n\t\t\t\tctx.results = Object.assign({}, result);\n\t\t\t\tresult[afterHandler] = await callIfSet(this._eventHandler[afterHandler], ctx, args);\n\n\t\t\t\tthis.__inTransition = false;\n\t\t\t\treturn result;\n\t\t\t} catch (e) {\n\t\t\t\tthis.__inTransition = false;\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t};\n\t}\n}\n\nmodule.exports = FSM;\n", "'use strict';\n\nmodule.exports = require('./lib/fsm');\n"],
  "mappings": "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",
  "names": ["require_fsm"]
}
